//
// Copyright (c) 2016-2017 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Contributors:
// Mark Struberg
// Emily Jiang
// John D. Ament
// Gunnar Morling

[[converter]]
== Converter

For providing type-safe configuration we need to convert from the configured Strings into target types.
This happens by providing ``Converter``s in the `Config`.

=== Built-in Converters

The following ``Converter``s are provided by MicroProfile-Config by default:

* `boolean` and `java.lang.Boolean` , values for `true` (case insensitive) "true", "1", "YES", "Y" "ON".
  Any other value will be interpreted as `false`
* `byte` and `java.lang.Byte`
* `short` and `java.lang.Short`
* `int` and `java.lang.Integer`
* `long` and `java.lang.Long`
* `float` and `java.lang.Float` , a dot '.' is used to separate the fractional digits
* `double` and `java.lang.Double` , a dot '.' is used to separate the fractional digits
* `char` and `java.lang.Character`
* `java.lang.Class` based on the result of `Class.forName`

All built-in ``Converter``s have the `@Priority` of `1`.


=== Adding custom Converters

A custom `Converter` must implement the generic interface `org.eclipse.microprofile.config.spi.Converter`.
The Type parameter of the interface is the target type the String is converted to.
You have to register your implementation in a file `/META-INF/services/org.eclipse.microprofile.config.spi.Converter` with the fully qualified class name of the custom implementation.

A custom `Converter` can define a priority with the `@javax.annotation.Priority` annotation.
If a Priority annotation isn't applied, a default priority of 100 is assumed.
The `Config` will use the `Converter` with the highest `Priority` for each target type.

A custom `Converter` for a target type of any of the built-in Converters will overwrite the default Converter.

Converters can be added to the `ConfigBuilder` programmatically via `ConfigBuilder#withConverters(Converter<?>... converters)`
where the type of the converters can be obtained via reflection. However, this is not possible for a lambda converter.
In this case, use the method `ConfigBuilder#withConverter(Class<T> type, int priority, Converter<T> converter)`.

=== Array Converters

For the built-in converters and custom converters, the corresponding Array converters are provided by default.
The delimiter for the config value is ",".
The escape character is "\".
e.g. With this config `myPets=dog,cat,dog\,cat`, the values as an array will be `{"dog", "cat", "dog,cat"}`.

==== Programmatic lookup

Array as a class type is supported in the programmatic lookup.

[source, java]
----
 String[] myPets = config.getValue("myPets", String[].class);
----

myPets will be "dog", "cat", "dog,cat" as an array

==== Injection model

For the property injection, Array, List and Set are supported.

[source, java]
----
@Inject @ConfigProperty(name="myPets") String[] myPetsArray;
@Inject @ConfigProperty(name="myPets") List<String> myPetsList;
@Inject @ConfigProperty(name="myPets") Set<String> myPetsSet;
----

myPets will be "dog", "cat", "dog,cat" as an array, List or Set.

=== Automatic Converters
If no built-in nor custom `Converter` exists for a requested Type `T`, an implicit `Converter` is automatically provided if the following conditions are met:

* The target type {@code T} has a {@code public static T of(String)} method, or
* The target type {@code T} has a {@code public static T valueOf(String)} method, or
* The target type {@code T} has a public Constructor with a String parameter, or
* The target type {@code T} has a {@code public static T parse(CharSequence)} method

=== Cleaning up a Converter

If a `Converter` implements the `java.lang.AutoCloseable` interface  then the `close()` method will be called when the underlying `Config` is being released.

=== Empty value

A config property can be explicitly configured with an empty value (the empty String `""`).  If a property
is missing and no default value exists for that property, it is considered to be empty.

The `Config.getValue()` method will normally throw a `NoSuchElementException` when a configuration value
is empty.  In order to allow empty values to be returned, either the `Config.getOptionalValue()`
method must be used, or a custom converter must be specified which provides a specific value for
the case where an empty value is returned (either implicitly due to the property being missing, or
explicitly due to an empty value being specified for a configuration property).

[NOTE]
This behaviour allows users to _unconfigure_ a property. If a property is configured in a lower-ordinal ConfigSource with
an undesirable value, you can set the property value to an empty string in a higher-ordinal ConfigSource to discard the lower-ordinal value.

When processing array or collection values, any empty array or collection segments must be excluded from the
resultant array or collection.

[[empty_value_table]]
.Examples of Config API behavior for empty values
[options="header"]
|=======================
| Property value | Output type | `Config` method | Output result
| missing     | `String` | `getValue` | throws `NoSuchElementException`
| `""` (empty string) | `String` | `getValue` | throws `NoSuchElementException`
| `" "`       | `String` | `getValue` | `" "`
| `"foo"`     | `String`   | `getValue` |  `"foo"`
| missing     | `String[]` | `getValue` | throws `NoSuchElementException`
| `""`        | `String[]` | `getValue` | throws `NoSuchElementException`
| `" "`       | `String[]` | `getValue` | `{ " " }`
| `","`       | `String[]` | `getValue` | throws `NoSuchElementException`
| `",,"`      | `String[]` | `getValue` | throws `NoSuchElementException`
| `"foo"`     | `String[]` | `getValue` | `{ "foo" }`
| `"foo,bar"` | `String[]` | `getValue` | `{ "foo", "bar" }`
| `"foo,"`    | `String[]` | `getValue` | `{ "foo" }`
| `",bar"`    | `String[]` | `getValue` | `{ "bar" }`
| `",bar,"`   | `String[]` | `getValue` | `{ "bar" }`
| missing     | `String` |`getOptionalValue` | `Optional.empty()`
| `""`        | `String` | `getOptionalValue` | `Optional.empty()`
| `" "`        | `String` | `getOptionalValue` | `Optional.of(" ")`
| `"foo"`     | `String` | `getOptionalValue` | `Optional.of("foo")`
| missing | `String[]` | `getOptionalValue` | `Optional.empty()`
| `""` | `String[]` | `getOptionalValue` | `Optional.empty()`
| `","` | `String[]` | `getOptionalValue` | `Optional.empty()`
| `",,"` | `String[]` | `getOptionalValue` | `Optional.empty()`
| `"foo,bar"` | `String[]` | `getOptionalValue` | `Optional.of({ "foo", "bar" })`
|=======================
